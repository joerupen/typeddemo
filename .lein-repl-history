exit
(require 'typeddemo :reload)
(use 'clojure.core.typed)
(check-ns typeddemo)
(check-ns 'typeddemo)
(declare abc)
(cf abc)
(ann abc Number)
(cf abc)
(declare abc)
(cf abc)
(def abc 1)
(cf abc)
(ann abc Number)
(def abc 1)
(cf abc)
(def foo Number)
(ann foo Number)
(def foo 1)
(cf foo)
(cf (ann abc Number))
(cf (def abc 1))
(cf abc)
(ann bar (Fn [Number -> Number]))
(defn bar [x] (inc x))
(cf bar)
(check-ns  'bar)
(check-ns  'user)
(ns typed.nocheck
  (:require [clojure.core.typed :refer [ann check-ns]]))
(ann ^:no-check foo (Fn [Number -> Number]))
(defn foo [a]
  'a)
(ann bar [Number -> Number])
(defn bar [b]
  (+ 2 (foo b)))
(check-ns)
(U Num)
(in-ns 'user)
(U Num)
(cf (U Num))
(cf (U Number))
(doc U)
(U Number)
(ann foo (U Number))
(def foo 1)
(cf foo)
(cf (def foo 1))
(defalias MyT (U Number))
(defalias MyT (U Number Long))
(doc TFn)
(source TFn)
(doc Fn)
(source Fn)
(check-ns  'typeddemo)
exit
(require 'typeddemo :reload)
(check-ns  'typeddemo)
(use 'clojure.core.typed)
(check-ns  'typeddemo)
(vec [1 2 3])
(check-ns  'typeddemo)
(list* [1 2 3])
(check-ns  'typeddemo)
(into () [1 2 3])
(check-ns  'typeddemo)
(into () [1 2 3])
(check-ns  'typeddemo)
(into () [1 2 3])
(check-ns  'typeddemo)
xit
exit
(ns typeddemo
  (:require [clojure.core.typed :as t]))
(t/defn checking  [x :- Number] :- String (str x))
(checking 49)
(checking [1 1 2])
(t/defn callcheck  [x :- Seq] :- String (checking x))
(callcheck 4)
(t/ann my-fn [t/AnyInteger -> String])
(defn my-fn [x] "1")
(t/ann red-fn [t/AnyInteger t/AnyInteger -> t/AnyInteger])
(defn red-fn [acc y] y)
(t/check-ns)
(t/ann my-fn [t/AnyInteger -> String])
(defn my-fn [x] "1")
(t/ann red-fn [t/AnyInteger t/AnyInteger -> t/AnyInteger])
(defn red-fn [acc y] y)
; doesn't work if you remove 0 below. reason: red-fn is applied with first 2 args of range but it's unclear
; if that's possible.
(defn call-my-fn [] (my-fn (reduce red-fn 0 (range 4))))
; awesome, here it works because we know we have 4 args.
(defn call-my-fn2 [] (my-fn (reduce red-fn  [1 2 3 4])))
; also here
(defn call-my-fn3 [] (my-fn (reduce red-fn  (vector 1 2 3 4))))
; fails again.
; (defn call-my-fn4 [] (my-fn (reduce red-fn  (vec (range 4)))))
; sad, fails to check that this is valid code.
;(defn call-my-fn5 [] (my-fn (reduce (fn [_ x] x) [1 2 3 4])))
; but if we hint it, it's okay.
(defn call-my-fn5 [] (my-fn (reduce (t/ann-form (fn [_ x] x) [t/AnyInteger t/AnyInteger -> t/AnyInteger]) [1 2 3 4])))
; this function is unkown type
(defn other-f [x] x)
; the following function would not be legal to call because x is unkown (any) and map needs a coll.
(t/tc-ignore
   (defn inc-coll [x]  (map inc x)))
(t/ann bar [Number -> Number])
(defn bar [b]
  (+ 2 b))
(t/ann c Number)
(def d 1)
(t/ann foo [Number -> Number])
(defn foo [x] (+ x d))
(foo "str")
(t/check-ns)
exit
(ns typeddemo
  (:require [clojure.core.typed :as t]))
(t/ann my-fn [t/AnyInteger -> String])
(t/check-ns)
(my-fn 33)
(cf (my-fn 33))
(t/cf (my-fn 33))
(t/cf (my-fn "dfdf"))
exit
(ns typeddemo
  (:require [clojure.core.typed :as t]))
(t/ann my-fn [t/AnyInteger -> String])
(t/check-ns)
(t/cf my-fn "34")
(t/cf (my-fn "34"))
(defn my-fn [x] "1")
(t/cf (my-fn "34"))
(t/ann my-fn [t/AnyInteger -> String])
(t/cf (my-fn "34"))
(t/ann my-fn [t/AnyInteger -> String])
(defn my-fn [x] "1")
(t/cf (my-fn "34"))
(t/cf (my-fn 1))
(t/ann my-fn [t/AnyInteger -> String])
(defn my-fn [x] "1")
(t/check-ns)
(t/cf (my-fn 1))
(t/ann my-fn [t/AnyInteger -> String])
(t/cf (my-fn 1))
(t/check-ns)
(meta my-fn)
exit
(require [clojure.core.typed :as t])
(require '[clojure.core.typed :as t])
(declare abc)
abc
#'abc
(ann abc Number)
(t/ann abc Number)
(cf abc)
(t/cf abc)
(t/cf (t/ann abc Number)))
(t/cf (t/ann abc Number))
(declare abc)
(t/cf (t/ann abc Number))
(t/cf (def abc 1))
(t/cf abc)
abc
(def b "str"))
(def b "str")
b
(t/cf b)
(t/cf (t/ann b String))
(t/cf b)
exit
(use 'clojure.core.typed)
(declare abc)
(cf abc)
(cf (ann abc Number))
(cf (def abc 1))
(def test String)
(def foo "string")
(ann foo String)
(cf foo)
foo
exit
(require '[clojure.core.typed :as t])
(doc t/cf)
(cf 1)
(t/cf 1)
(t/f inc)
(t/cf inc)
(t/cf map)
(t/cf reduce)
(t/cf partition)
(t/cf sort-by)
(t/cf group-by))
(t/cf group-by)
(t/cf dec)
(t/cf +)
(t/cf juxt)
(t/cf keep)
(t/cf identity)
(t/cf removd)
(t/cf remove)
(t/cf hash-set)
(t/cf or)
(t/cf and)
(t/cf while)
(t/cf doseq)
(t/cf for)
(t/cf pop)
exit
(require '[clojure.core.typed :as t])
(t/check-ns)
(doc t/check-ns)
(t/check-ns typeddemo)
(t/check-ns 'typeddemo)
(t/cf {:a 1 :b 2})
(t/cf {:a 1 :b 2} (t/Seqable '[Kw Num]))
(t/cf {:a 1 :b 2} (t/Seqable '[t/Kw t/Num]))
(t/cf (map inc [1 2 3 4]))
(t/cf (reduce + [1 2 3 4]))
(t/cf (reduce + [1 2 3 4.5]))
(declare bar)
(t/ann bar String)
(def bar "s")
(t/cf bar)
(t/ann bar String)
(t/cf bar)
(t/cf map)
(t/def foo :- String "s")
(t/cf foo)
(require 'typeddemo)
(in-ns 'typeddemo)
(t/cf my-fn)
(t/cf my-fn 3)
(t/cf (my-fn 3))
(t/cf (if 4 (my-fn 9) :kw))
(t/cf (if nil (my-fn 9) :kw))
(t/cf (if a (my-fn 9) :kw))
(def a 2)
(t/cf (if a (my-fn 9) :kw))
(t/cf (t/let [a :- Number 4] (if a (my-fn 9) :kw)))
(t/cf my-fn )
(t/cf (let [f :- [Number -> Number] inc a :- Number 6] (f a)))
(t/cf (let [f :- [Number -> Number] inc] (f 1)))
(t/cf (t/let [f :- [Number -> Number] inc] (f 1)))
(t/cf (t/let [f :- [Number -> Number] map] (f 1)))
(t/cf (map inc 1))
(t/cf (let [b 25 ](map inc b)))
(t/check-ns)
(t/cf (any-to-any "sdtring"))
eixt
exit
(require 'clojure.core.typed)
(in-ns 'clojure.core.typed)
(cf (ann abc Number))
(cf (def abc 1))
(cf abc)
exit
(require '[clojure.core.typed :as t])
(cf (ann abc Number))
(t/cf (ann abc Number))
(t/cf (t/ann abc Number))
(t/cf (def abc 1))
(t/cf (t/ann foo Number))
(t/cf (def foo "string"))
(t/cf (let [s "str"] (def foo s)))
(t/defn any-to-any :- [t/Any -> t/Any] [x] x)
(t/cf any-to-any)
(t/cf abc)
 any-to-any
(t/cf (any-to-any :x))
(t/cf (t/ann any-to-any [t/Any -> t/Any]))
(t/cf (defn any-to-any [x] x))
(t/cf (any-to-any :x))
(t/cf any-to-any )
(t/defn any-to-num :- [t/Any -> t/Num] [x] x)
(t/cf any-to-any )
(t/cf any-to-num )
(t/defn any-to-num [x :- t/Any] :- t/Num 5)
(t/cf any-to-num )
(t/cf any-to-any )
(t/cf (t/fn [x :- t/Num]) x )
(t/cf (t/fn [x :- t/Num] x ))
(t/cf (t/fn [x :- t/Num] :- t/Any x ))
(def fx (t/fn [x :- t/Num] :- t/Any x ))
(t/cf fx)
(t/cf string?)
(t/cf seq)
(clojure.pprint/pprint (t/cf seq))
(t/defn> any-to-num [x :- t/Any] :- t/Num 5)
(t/defn> any-to-num :- t/Num [x :- t/Any] 5)
(t/cf any-to-num)
(def foobar [x] x)
(defn foobar [x] x)
(t/ann foo [t/Num -> t/Num])
(t/ann foobar [t/Num -> t/Num])
(t/cf foobar)
(t/ann foobar [t/Num -> t/Num])
(defn foobar [x] x)
(t/cf foobar)
(def foobar (fn[x] x))
(t/ann foobar [t/Num -> t/Num])
(t/cf foobar)
exit
(require '[clojure.core.typed :as t])
(defn foo [x] x)
(t/ann foo [t/Any -> t/Any])
(t/cf foo)
(def bar 5)
(t/ann bar Num)
(t/cf bar)
(declare bar)
(t/ann bar Num)
(def bar 5)
(t/cf bar)
(t/ann bar t/Num)
(t/cf bar)
exit
(require '[clojure.core.typed :as t])
(def bar 5)
(t/ann bar t/Num)
(t/cf bar)
(t/cf (t/defn any-to-any [x :- t/Any ] :- t/Any x))
(t/cf any-to-any)
(t/check-ns)
(t/check-ns 'typeddemo)
(t/envs)
(clojure.pprint/pprint (t/envs))
(clojure.pprint/pprint (keys (t/envs)))
(clojure.pprint/pprint (:aliases (t/envs)))
(clojure.pprint/pprint (keys (t/envs)))
(clojure.pprint/pprint (keys (:vars (t/envs))))
(clojure.pprint/pprint (keys (t/envs)))
(clojure.pprint/pprint (keys (:aliases (t/envs))))
(clojure.pprint/pprint (get (:aliases (t/envs)) 'clojure.core.typed/Fn))
(clojure.pprint/pprint (get (:aliases (t/envs)) clojure.core.typed/Fn))
(clojure.pprint/pprint (keys (:aliases (t/envs))))
(clojure.pprint/pprint (:aliases (t/envs)))
(clojure.pprint/pprint (get-in t/envs [:aliases 'clojure.core.typed/Set]))
(clojure.pprint/pprint (get-in t/envs [:aliases clojure.core.typed/Set]))
(clojure.pprint/pprint (get-in t/envs [:aliases #'clojure.core.typed/Set]))
(clojure.pprint/pprint (map type (keys (:aliases (t/envs)))))
(clojure.pprint/pprint (get-in t/envs [:aliases 'clojure.core.typed/Set]))
(clojure.pprint/pprint (get-in t/envs [:aliases ]))
 (get-in t/envs [:aliases ])
 (get-in t/envs [ ])
 (get-in (t/envs) [:aliases ])
(keys (get-in (t/envs) [:aliases]))
(clojure.pprint/pprint (:aliases (t/envs)))
(clojure.pprint/pprint (get-in (t/envs) [:aliases 'clojure.core.typed/Set]))
(clojure.pprint/pprint (get-in (t/envs) [:aliases 'clojure.core.typed/Seq]))
(clojure.pprint/pprint (get-in (t/envs) [:aliases 'clojure.core.typed/ASeq]))
(clojure.pprint/pprint (get-in (t/envs) [:aliases 'clojure.core.typed/TFn]))
(clojure.pprint/pprint (get-in (t/envs) [:aliases 'clojure.core.typed/Fn]))
(clojure.pprint/pprint (get-in (t/envs) [:aliases 'clojure.core.typed/IFn]))
(clojure.pprint/pprint (get-in (t/envs) [:aliases 'clojure.core.typed/Seqable]))
(clojure.pprint/pprint (get-in (t/envs) [:aliases 'clojure.core.typed/HSeq]))
(t/cf {})
(t/cf {:a 1})
(t/cf {:a 1 :b 2})
(t/ann qux t/Num)
(clojure.pprint/pprint (get-in (t/envs) [:aliases 'user/qux]))
(t/ann (t/def qux :- t/Num))
(t/cf (t/def qux :- t/Num))
(t/cf (t/def qux :- t/Num 55))
(clojure.pprint/pprint (get-in (t/envs) [:aliases 'user/qux]))
qux
(clojure.pprint/pprint (keys (t/envs)))
(clojure.pprint/pprint (get-in (t/envs) [:vars 'user/qux]))
(t/ann qux2 t/Num)
(clojure.pprint/pprint (get-in (t/envs) [:vars 'user/qux2]))
(declare qux2)
(t/ann qux2 t/Num)
(clojure.pprint/pprint (get-in (t/envs) [:vars 'user/qux2]))
(t/ann #'qux2 t/Num)
#'qux2
(def qux2 44)
(clojure.pprint/pprint (get-in (t/envs) [:vars 'user/qux2]))
(t/ann #'qux2 t/Num)
(t/ann (var qux2) t/Num)
(t/ann qux2 t/Num)
(clojure.pprint/pprint (get-in (t/envs) [:vars 'user/qux2]))
(t/ann user/qux2 t/Num)
(clojure.pprint/pprint (get-in (t/envs) [:vars 'user/qux2]))
(declare jon)
(t/ann jon t/Num)
(def jon 34()
)
(def jon 34)
(clojure.pprint/pprint (get-in (t/envs) [:vars 'user/jon]))
exit
(require '[clojure.core.typed :as t])
(t/cs 1)
(t/cf 1)
(t/cf "sgtring")
(t/cf [1 2 3 ])
(t/cf (list 1 2 3 ))
(t/cf (list 2 1 3 ))
(t/cf [1 3 2 ])
(t/cf [1 3 "str" ])
(t/cf (map inc [1 3 2 ]))
(t/cf (map inc [ ]))
(t/cf (map vector [ ]))
(t/cf (map vector [1 2 3 ]))
(t/cf (vector [1 2 3 ])
)
(t/cf (map vec [1 2 3 ]))
(t/cf (map vector [1 2 3 ]))
(t/cf (filter odd? [1 2 3 ]))
(t/cf (remove odd? [1 2 3 ]))
(t/cf (map str [1 2 3 ]))
(t/cf (def a [1 2 3])))
(t/cf (def a [1 2 3]))
(t/cf (t/defn foo [x :- t/Num] :- t/Str (str x)))
(foo 4)
(t/cf (map foo [1 2 3 ]))
(t/cf (t/defn foo [x :- t/Num] :- t/Vec (vector x)))
(t/cf (t/defn foo [x :- t/Num] :- (t/Vec t/Number) (vector x)))
(t/cf (t/defn foo [x :- t/Num] :- (t/Vec t/Num) (vector x)))
(t/cf (t/defn bar [x :- t/Num] :- (t/Vec t/Num) (vector x)))
(t/cf (map bar [1 2 3 ]))
(t/cf (Let [c [1 2 3]] (map inc c)))
(t/cf (let [c [1 2 3]] (map inc c)))
(t/cf (let [c [1 2 3]] (map vector c)))
(t/cf (let [c [1 2 3]] (vector c)))
(t/cf (let [c [1 2 3]] (map vector c)))
exit
(require '[clojure.core.typed :as t])
(t/cf 55)
(t/cf (map vector [1 2 3]))
(t/cf (map vector nil))
(t/cf vector)
(t/cf map)
(t/cf reduce)
(t/cf partition)
(t/cf hash-map)
(t/cf hash-set)
(t/cf hash-map)
(t/cf apply)
(def x (t/cf apply))
(type x)
(clojure.pprint/pprint x)
(def pp clojure.pprint/pprint)
(def p clojure.pprint/pprint)
(p (t/cf apply))
(p (t/cf (apply + 1 2 3)))
 (apply + 1 2 3))
 (apply + 1 2 3)
 (apply + [1 2 3])
(p (t/cf (apply + [1 2 3])))
(p (t/cf condp))
(p (t/cf cond))
(p (t/cf (doseq [x ()] nil)))
(p (t/cf (if (= 1 2) 1 "str" )))
(def x 99)
(p (t/cf (if (= x 2) 1 "str" )))
(t/cf (def x 99))
(p (t/cf (if (= x 2) 1 "str" )))
(p (t/cf (if (= (rand-int 5) 2) 1 "str" )))
(if (= (rand-int 5) 2) 1 "str" ))
(if (= (rand-int 5) 2) 1 "str" )
(p (t/cf (if (= (rand-int 5) 2) 1 "str" )))
(t/cf rand-int)
(p (t/cf (and true false)))
(p (t/cf (and true true false)))
(p (t/cf (or true true false)))
(p (t/cf (if (= "asdf" 2) 1 "str" )))
(if (= "asdf" 2) 1 "str" ))
(if (= "asdf" 2) 1 "str" )
(p (t/cf (if (= "asdf" 2) 1 "str" )))
(p (t/cf (if (= (rand-int 5) 2) 1 nil )))
(p (t/cf (if (= "asdf" 2) 1 "str" )))
(p (t/cf (fn [x] x))
)
(p (t/cf (fn [x] x)))
(p (t/cf (fn [x] (inc x)))
)
(p (t/cf (fn [x] x)))
(p (t/cf (t/fn [x :- t/Num] x)))
(p (t/cf (t/fn [x :- t/Num y :- t/Long] (+ x y))))
(p (t/cf (t/fn [x :- t/Num y :- t/long] (+ x y))))
(p (t/cf (t/fn [x :- t/Num y :- t/Int] (+ x y))))
(p (t/cf (t/fn [x :- t/Num y :- t/Vec] (map inc y))))
(p (t/cf (t/fn [x :- t/Num y :- [t/Vec t/Int]] (map inc y))))
(p (t/cf (t/fn [x :- t/Num y :- (t/Vec t/Int)] (map inc y))))
(p (t/cf (t/fn [x :- t/Num y :- [t/Vec t/Int]] (map inc y))))
(p (t/cf (t/fn [x :- t/Num y :- (t/Vec t/Int)] (map inc y))))
(p (t/cf (t/fn [x :- t/Num y :- (t/Vec t/Int)] (map #(+ x %) y))))
(p (t/cf (t/fn [x :- t/Num y :- (t/Vec t/Int)] (map (fn [p :- t/Int] (+ x p)) y))))
(t/fn [x :- t/Num y :- (t/Vec t/Int)] (map (fn [p :- t/Int] (+ x p)) y)))
(t/fn [x :- t/Num y :- (t/Vec t/Int)] (map (fn [p :- t/Int] (+ x p)) y))
(p (t/cf (t/fn [x :- t/Num y :- (t/Vec t/Int)] (map (fn [p :- t/Int] (+ x p)) y))))
(p (t/cf (t/fn [x :- t/Num y :- (t/Vec t/Int)] (map (t/fn [p :- t/Int] (+ x p)) y))))
(p (t/cf {})
)
(p (t/cf {}))
(p (t/cf {:k 1}))
exit
(require '[clojure.core.typed :as t])
(t/cf (+ 2 3))
exit
